from flask import request, jsonify
from routes import api
from database import db
from models.process import Process
from utils.auth import auth_required
from datetime import datetime
import re


@api.get("/reports/summary")
@auth_required()
def report_summary():
    rows = (
        db.session.query(Process.producto_id, db.func.sum(Process.piezas))
        .group_by(Process.producto_id)
        .all()
    )
    data = [{"producto_id": r[0], "piezas": float(r[1] or 0)} for r in rows]
    return jsonify(data)


def _parse_date(s: str | None):
    if not s:
        return None
    for fmt in ("%Y-%m-%d", "%d/%m/%Y"):
        try:
            return datetime.strptime(s, fmt).date()
        except ValueError:
            continue
    return None


@api.get("/reports/inventory")
@auth_required()
def report_inventory():
    d_from = _parse_date(request.args.get("from"))
    d_to = _parse_date(request.args.get("to"))
    mr = request.args.get("mr")
    columns = request.args.get("columns")

    def _ident(name: str) -> str:
        if not name:
            raise ValueError("Empty identifier")
        if not re.fullmatch(r"[A-Za-z0-9_\.]+", name):
            raise ValueError(f"Invalid identifier: {name}")
        return ".".join(f"[{p}]" for p in name.split("."))

    # Procesos como fuente principal
    proct = "dbo.procesos"
    cli_tbl = "dbo.clientes"
    prod_tbl = "dbo.productos"
    est_tbl = "dbo.estaciones"
    usu_tbl = "dbo.usuarios"

    # Descubrir columnas presentes para JOINs opcionales (usuario/estaciÃ³n/fechas)
    def _cols_of(tbl: str) -> set:
        try:
            rs = db.session.execute(
                db.text("SELECT name FROM sys.columns WHERE object_id = OBJECT_ID(:t)")
            , {"t": tbl}).fetchall()
            return {r[0] for r in rs}
        except Exception:
            return set()

    pcols = _cols_of(proct)
    ccols = _cols_of(cli_tbl)
    has_pr_est = "estacion_id" in pcols
    has_pr_usu = "usuario_id" in pcols
    has_cli_usu = "usuario_id" in ccols
    has_created_at = "created_at" in pcols

    sel = [
        "pr.[id] AS [Folio]",
        "pr.[op] AS [OP]",
        "CASE WHEN c.[nombre] LIKE 'AUTO-%' THEN NULL ELSE c.[nombre] END AS [IdClie]",
        "CASE WHEN p.[nombre] LIKE 'AUTO-%' THEN NULL ELSE p.[nombre] END AS [IdProd]",
        "CASE WHEN pr.[variable1] LIKE 'AUTO-%' THEN NULL ELSE pr.[variable1] END AS [Var1]",
        "CASE WHEN pr.[variable2] LIKE 'AUTO-%' THEN NULL ELSE pr.[variable2] END AS [Var2]",
        "CASE WHEN pr.[variable3] LIKE 'AUTO-%' THEN NULL ELSE pr.[variable3] END AS [Var3]",
        "pr.[piezas] AS [Pzas]",
        "p.[peso_por_pieza] AS [PxP]",
        "ROUND(COALESCE(pr.[piezas],0) * COALESCE(p.[peso_por_pieza],0), 2) AS [Peso]",
        "pr.[lote] AS [Lote]",
        ("CASE WHEN s.[nombre] LIKE 'AUTO-%' THEN NULL ELSE s.[nombre] END AS [IdEst]" if has_pr_est else "CAST(NULL AS NVARCHAR(50)) AS [IdEst]"),
        ("CASE WHEN u.[nombre] LIKE 'AUTO-%' THEN NULL ELSE u.[nombre] END AS [IdUsu]" if (has_pr_usu or has_cli_usu) else "CAST(NULL AS NVARCHAR(50)) AS [IdUsu]"),
        ("CAST(pr.[created_at] AS DATE) AS [Fecha]" if has_created_at else "CAST(NULL AS DATE) AS [Fecha]"),
    ]

    sql_parts = [
        "SELECT ", ", ".join(sel),
        f" FROM {_ident(proct)} AS pr",
        f" JOIN {_ident(cli_tbl)} AS c ON c.[id] = pr.[cliente_id]",
        f" JOIN {_ident(prod_tbl)} AS p ON p.[id] = pr.[producto_id]",
    ]
    if has_pr_est:
        sql_parts.append(f" LEFT JOIN {_ident(est_tbl)} AS s ON s.[id] = pr.[estacion_id]")
    if has_pr_usu:
        sql_parts.append(f" LEFT JOIN {_ident(usu_tbl)} AS u ON u.[id] = pr.[usuario_id]")
    elif has_cli_usu:
        sql_parts.append(f" LEFT JOIN {_ident(usu_tbl)} AS u ON u.[id] = c.[usuario_id]")

    where = []
    params = {}
    if mr:
        where.append("pr.[op] LIKE :mr")
        params["mr"] = f"%{mr}%"
    if d_from and has_created_at:
        where.append("CAST(pr.[created_at] AS DATE) >= :dfrom")
        params["dfrom"] = d_from
    if d_to and has_created_at:
        where.append("CAST(pr.[created_at] AS DATE) <= :dto")
        params["dto"] = d_to
    if where:
        sql_parts.append(" WHERE " + " AND ".join(where))
    if has_created_at:
        sql_parts.append(" ORDER BY pr.[created_at] DESC")
    else:
        sql_parts.append(" ORDER BY pr.[id] DESC")

    sql = "".join(sql_parts)
    rows = db.session.execute(db.text(sql), params).mappings().all()
    if columns:
        cols = [c for c in columns.split(",") if c]
    elif rows:
        cols = list(rows[0].keys())
    else:
        cols = []
    data = []
    for r in rows:
        m = {k: r.get(k) for k in cols}
        for k, v in list(m.items()):
            if hasattr(v, "isoformat"):
                try:
                    m[k] = v.isoformat()
                except Exception:
                    m[k] = str(v)
        data.append(m)
    return jsonify({"columns": cols, "rows": data})
